# Java基础

## jdk1.5之后的三大版本

### Java SE

也称 J2SE  （标准版）。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使 用的 Java 应用程序。Java SE 包含了支持 Java Web 服务开发的类，并为Java EE和Java ME提供基础。

### Java EE

也称 J2EE （企业版）。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器 端Java 应用程序。Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、 管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web2.0应用程序。

### Java ME

也称J2ME（微型版）。Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视 机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME 包括灵活的用 户界面、健壮的安全模型、许多内置的网络协议以及对可以动态下载的连网和离线应用程序 的丰富支持。

### J2SE，J2EE，J2ME的联系与区别

j2se，是java2的标准版，主要用于开发桌面的应用程序。

j2ee，是java2的企业版，主要用于[分布式](https://so.csdn.net/so/search?q=分布式&spm=1001.2101.3001.7020)的网络程序的开发。在J2SE的基础上添加了一系列的企业级应用编程接口.J2EE包含有很多的技术！其中有你熟悉的jsp，servlet，jdbc，jme等13中技术

j2me，是java2的微型版，主要应用于嵌入式系统开发，用于消费类电子产品的软件开发，比如：呼机、智能卡、手机、PDA、机顶盒

> J2SE是基础；
>
> 压缩一点，再增加一些CLDC等方面的特性就是J2ME；
>
> 扩充一点，再增加一些EJB等企业应用方面的特性就是J2EE

J2SE包含于J2EE中，J2ME包含了J2SE的核心类，但新添加了一些专有类

![image-20220713093530584](https://picgo111.oss-cn-beijing.aliyuncs.com/image-20220713093530584.png)

## JVM、JRE、JDK的关系

JVM : Java Virtual Machine是Java虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。（Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安 装相应的java虚机，该系统就可以运行java程序。）

JRE : Java Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。核 心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包。如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。

JDK : Java Development Kit是提供给Java开发人员使用的，其中包含了Java的开发 工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。其中的开发工 具：编译工具(javac.exe)，打包工具(jar.exe)等。

![image-20220713094014205](https://picgo111.oss-cn-beijing.aliyuncs.com/image-20220713094014205.png)

## 字节码

### 什么是字节码？

Java源代码经过虚拟机编译器编译后产生的文件（即扩展为.class的文 件），它不面向任何特定的处理器，只面向虚拟机。

### 采用字节码的好处

在一定程度上解决了传统解释型语言执行效率低的 问题，同时又保留了解释型语言可移植的特点。由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。

### java程序的执行过程

Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节 码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行，这就是上面提到的Java的特点的编译与解释并存的解释。

```
Java源代码---->编译器---->jvm可执行的Java字节码(即虚拟指令)---->jvm---->jvm中 解释器-----> 机器可执行的二进制机器码---->程序运行
```

## 基础语法

### 数据类型

#### 基本数据类型

![image-20220713095848065](https://picgo111.oss-cn-beijing.aliyuncs.com/image-20220713095848065.png)

1. 自动转换：

   byte -> short -> int ->long -> float -> double  

   范围小的可以自动转换成范围大的

   char -> int    (转换成ascii码)

   boolean 不能与其他类型进行转换

   **注**：自动转换可能出现精度的丢失

2. 强制转换：

   需要类型转换符   `(数据类型)`

   **注**：可能出现精度的丢失，还会出现数据的溢出

3. 特殊情况及案例

   java中，整数的默认类型是int，浮点数的默认类型是double

   ```
   float f=3.4;是否正确
   ans: 不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于 下转型（down-casting，
   也称为窄化）会造成精度损失，因此需要强制类型转 换float f =(float)3.4; 或者写成 float f =3.4F;
   ```

   ```
   short s1 = 1; s1 = s1 + 1;有错吗? short s1 = 1; s1 += 1;有错吗
   ans: 对于 short s1 = 1; s1 = s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结果也是 int型，需要强制转换类型才能赋值给 short 型。 
   	而 short s1 = 1; s1 += 1;可以正确编译，因为 s1+= 1;相当于 s1 = (short(s1 + 1);其中有隐含的强制类型转换。
   ```

   ```
   byte b2 = 'a'       //是正确的，因为字符常量在编译时会转成int整数 short同理
   char c = 65 		//是正确的，按照ascii码转换  可以赋值为0-65535的整数
   ```



#### 引用类型

1. 类（class）
2. 接口（interface）
3. 数组（[]）



### 运算符

#### 逻辑运算符

1. 逻辑与  && &

   &&和&的区别：

   &&是短路与，即第一个为false，返回false，不执行第二个

   &是逻辑与，两个都执行

2. 逻辑或 || |

   ||是短路与，即第一个为false，返回false，不执行第二个

   |是逻辑与，两个都执行

3. 逻辑非 ！

#### 位运算

https://blog.csdn.net/weixin_39410864/article/details/123000487

左移位相当于 *(2^n)

右移位相当于 /(2^n)

#### 赋值运算符

使用复合赋值运算符时，完全由JVM自动地处理数据类型

#### 运算符优先级

优先级由高到底的顺序依次是：增量和减量运算→算术运算符→比较运算→逻辑运算→赋值运算

![image-20220713110225832](https://picgo111.oss-cn-beijing.aliyuncs.com/image-20220713110225832.png)

示例：

```
int x, y;
x = y = 10;
// 1. y = 10;
// 2. x = (y = 10);     //x=10

int n, m=n=10;	//正确
int m=n=10;		//报错， n没有声明
```



### 关键字

#### 权限修饰符

private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部 类）

default (即缺省，什么也不写，不使用任何关键字）: 在同一包内可见，不使用 任何修饰符。使用对象：类、接口、变量、方法。

protected : 对同一包内的 类和所有子类可见。使用对象：变量、方法。 注意： 不能修饰类（外部类）。

​					包外的子类中只能访问当前类继承而来的protected，不能访问父类继承而来的。

public : 对所有类可见。使用对象：类、接口、变量、方法

![image-20220713103925763](https://picgo111.oss-cn-beijing.aliyuncs.com/image-20220713103925763.png)

**注：权限修饰符中的protected、private只能修饰类内部的东西，不能修饰外部类**

#### final

**final有什么用？ ans: 用于修饰类，属性和方法；**

1. 被final修饰的类不可以被继承

2. 被final修饰的方法不可以被重写

3. 被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以被修改的。

   

**final finally finalize 区别**

1. final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。

2. finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。

3. finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的最后判断。

   

#### this

this是自身的一个对象，代表对象本身

用法可以分为3种：

1. 普通的直接引用，this相当于是指向当前对象本身。

2. 形参与成员名字重名，用this来区分。

3. 引用本类的构造函数

   ```
   class Person {
       private String name;
       private int age;
   
       public Person() {
       }
   
       public Person(String name) {
           this.name = name;
       }
   
       public Person(String name, int age) {
           //调用本类的构造方法
           this(name);
           this.age = age;
       }
   }
   
   ```

#### super

super可以理解为是指向自己超类（父类）对象的一个指针，而这个超类指的是离自己最近的一个父类。

用法可以分为3种：

1. 普通的直接引用

   super相当于指向当前父类的引用，这样可以用super.xxx来引用父类的成员

2. 子类中的成员变量或方法于父类中的成员变量或方法同名时，用super进行分区

   ```
   class Person {
       protected String name;
   
       public Person(String name) {
           this.name = name;
   
       }
   }
   
   class Student extends Person {
       private String name;
   
       public Student(String name, String name1) {
           super(name);
           this.name = name1;
   
       }
   
       public void getInfo() {
           System.out.println(this.name); //Child
           System.out.println(super.name); //Father
       }
   }
   
   public class test01 {
       public static void main(String[] args) {
           Student s1 = new Student("Father", "Child");
           s1.getInfo();
       }
   }
   ```

3. 引用父类构造函数

   super(参数)：调用父类中的某一个构造函数 (若使用 必须为构造函数中的第一条语句)

   this(参数): 调用本类中另一种形式的构造函数（若使用 必须为构造函数中的第一条语句）

   

#### this与super的区别与联系

super()在子类中调用父类的构造方法，this()在本类内调用本类的其它构造方法。

super()和this()均需放在构造方法内第一行。

this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。

this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。

从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。

#### static

被static修饰的，都会变成静态的

在JVM的内存方法中有一块区域叫静态池。JDK8方法区变成元空间，静态池被转移到了堆中

##### 作用

1. static的主要意义是在于创建独立于具体对象的域变量或者方法。以致于即使没有创建对象，也能使用属性和调用方法

2. static关键字还有一个比较关键的作用就是 用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次。因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。

##### 特点

1. 被static修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法不属于任何一个实例对象，而是被类的实例对象所共享。
2. 在该类被第一次加载的时候，就会去加载被static修饰的部分，而且只在类第一次使用时加载并进行初始化，注意这是第一次用就要初始化，后面根据需要是可以再次赋值的。
3. static变量值在类加载的时候分配空间，以后创建类对象的时候不会重新分配。赋值的话，是可以任意赋值的！
4. 被static修饰的变量或者方法是优先于对象存在的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。（与1同理）

##### 应用场景

1.修饰成员变量；2.修饰成员方法；3.静态代码块；4.修饰类【只能修饰内部类也就是静态内部类】；5.静态导包

##### 注意

1. 静态只能访问静态

2. 非静态既可以访问静态的，也可以访问非静态的

   

## 面向对象

### 面向过程和面向对象

**面向过程：**

解决问题时，关注的是问题解决的步骤。

案例：把大象装冰箱

步骤： 总共分3步   1.把冰箱门打开；2.把大象装进去；3.把冰箱门关上。

**面向对象：**

解决问题时，关注的是问题中所涉及的对象，以及对象的特征和行为，再通过对象的特种以及行为组合在一起，从而解决问题。 （把事物的特征和行为抽象成一个对象，把事物对象化）

案例：把大象装冰箱

1. 分析问题中涉及的对象：冰箱，大象

2. 分析每个对象的特征和行为：冰箱的行为：开门、装(东西)、关门

   ​												  大象的行为：无

3. 将对象的特征和行为进行组合：冰箱.开门();  冰箱.装(大象); 冰箱.关门();

   

### 面向对象三大特征

#### 封装

封装是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。

封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如 果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没 有提供给外界访问的方法，那么这个类也没有什么意义了。

#### 继承

 继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新 的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用 继承我们能够非常方便地复用以前的代码。继承是多态的前提

注：

1. 子类拥有父类非 private 的属性和方法。

		2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
		2. 子类可以用自己的方式实现父类的方法（重写）。

#### 多态

多态是指相同或近似的代码，在执行时表现出不同的形态，调用不同的方法。

是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出 的方法调用在编程时并不确定，而是在程序运行期间才确定，即**一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定**。

在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口 （实现接口并覆盖接口中同一方法）。

**方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。**

java实现多态有3个必要条件：继承、重写、向上转型

**向上转型**：上转型对象可以调用被子类继承的变量和方法，不能调用子类自己创建的变量和方法，

向上转型对多态性的体现：不同的子类在重写父类的方法时可能产生不同的行为。

上转型对象 创建的子类对象，并将这个对象的引用赋值给父类对象。

#### 抽象（第四特性）

抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。

### 类与接口

#### 类

类是抽象的，是世界中具有相同特征和行为的事物的统称。比如：人

类关注的是事物的特征和行为

在类中，特征使用属性描述，行为使用方法进行描述

**对象是类的实例**  ：即 张三是一个人，那么张三是对象，人是类     张三是人的实例

q: **对象实例与对象引用有何不同？**

a: new创建对象实例（对象实例在堆内存中），对象引用指向对象实 例（对象引用存放在栈内存中）。一个对象引用可以指向0个或1个对象;一个对象可以有n个引用指向它

#### 抽象类

 abstract class 来定义抽象类

如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。

抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。

q: **抽象类能使用final修饰吗？**

a: 不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承， 这样彼此就会产生矛盾，所以 final 不能修饰抽象类

规定：

1. 一个类只能继承一个抽象类
2. 抽象类不能被实例化，只有抽象类的非抽象子类可以创建对象。
3.  抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。
4. 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。
5. 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。
6. 抽象类没有构造方法

##### 抽象方法

抽象方法指一些**只有方法声明，而没有具体方法体**的方法

如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法

abstract 关键字也可以用来声明抽象方法

> - 如果一个类包含抽象方法，那么该类必须是抽象类。
> - 任何子类必须重写父类的抽象方法，或者声明自身为抽象类。

继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。



#### 接口

接口通常以interface来声明

类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。

接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。

接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。

特点：

1. 接口中的属性，默认使用public static final 修饰，即公共的静态常量
2. 接口中的属性，默认使用public abstract 修饰，即公共的抽象方法

##### 接口与类的区别

1. 接口不能用于实例化对象。
2. 接口没有构造方法。
3. 接口中所有的方法必须是抽象方法，Java 8 之后 接口中可以使用 default 关键字修饰的非抽象方法。
4. 接口不能包含成员变量，除了 static 和 final 变量。
5. 接口不是被类继承了，而是要被类实现。
6. 接口支持多继承。

##### 接口与抽象类的区别

1. 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。

2. 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 **public static final** 类型的。

3. 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。

4. 一个类只能继承一个抽象类，而一个类却可以实现多个接口。

   > JDK 1.8 以后，接口里可以有静态方法和方法体了。
   >
   > JDK 1.8 以后，接口允许包含具体实现的方法，该方法称为"默认方法"，默认方法使用 default 关键字修饰。实现类可以选择重写，也可以不重写。
   >
   > JDK 1.9 以后，允许将方法定义为 private，使得某些复用的代码不会把方法暴露出去。

### 变量与方法

1. 成员变量与局部变量的不同

   ans:

   1）存储位置：

   成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在**堆内存**中。

   局部变量：在方法被调用，或者语句被执行的时候存在，存储在**栈内存**中。当方法调用完，或者语句结束后，就自动释放。

   2）生命周期：

   成员变量：随着对象的创建而存在，随着对象的消失而消失

   局部变量：当方法调用完，或者语句结束后，就自动释放。

   3）初始值：

   成员变量：有默认初始值。（类0值）

   局部变量：没有默认初始值，使用前必须赋值。

2. 静态变量和实例变量的区别

   ans:

   静态变量： 静态变量由于不属于任何实例对象，属于类的，所以在内存中只会有一份，在类的加载过程中，JVM只为静态变量分配一次内存空间。

   实例变量： 每次创建对象，都会为每个对象分配成员变量内存空间，实例变量 是属于实例对象的，在内存中，创建几次对象，就有几份成员变量。

   

### 构造方法

当类中没有任何构造方法时，系统会默认加上无参构造

注：**子类构造方法无论如何都要调用父类的构造方法** 

原因：子类继承父类后，获取到父类的属性和方法，这些属性和方法在使用前必须先初始化，所以须先调用父类的构造器进行初始化

> Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中的无参构造方法。
>
> 因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时会报错。因为在父类中找不到没有参数的构造方法可供执行

问题：

1. 在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？

   ans: 帮助子类做初始化工作

   

### 内部类

内部类可以分为四种：成员内部类、局部内部类、匿名内部类和静态内部类。

#### 一、静态内部类

定义在类内部的静态类，就是静态内部类

静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量；

```
public class Outer {

    private static int n = 1;

    static class StaticInner{
        public void visit(){
            System.out.println("静态内部类");
        }
    }
}

// 静态内部类的实例化方式   Outer.StaticInner inner = new Outer.StaticInner();
```

#### 二、成员内部类

定义在类内部，成员位置上的非静态类，就是成员内部类。

```
public class Outer {

    private static int n = 1;

    class Inner{
        public void visit(){
            System.out.println("成员内部类");
        }
    }
}

// 成员内部类的实例化方式   Outer.Inner inner = new Outer.Inner();
```

#### 三、局部内部类

定义在方法中的内部类，就是局部内部类

定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法 中的局部类只能访问外部类的静态变量和方法。

#### 四、匿名内部类

匿名内部类就是没有名字的内部类（使用最多）

特点：

1. 匿名内部类必须继承一个抽象类或者实现一个接口
2. 匿名内部类不能定义任何静态成员和静态方法
3. 当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。
4. 匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。

#### 内部类的优点

1. 一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据！

2. 内部类不为同一包的其他类所见，具有很好的封装性；

3. 内部类有效实现了“多重继承”，优化 java 单继承的缺陷；

4. 匿名内部类可以很方便的定义回调。

## 对象相等判断

### ==和equals的区别

**==：**

它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同 一个对象。(基本数据类型== 比较的是值，引用数据类型 == 比较的是内存地址)

**equals： **

它的作用也是判断两个对象是否相等。但它一般有两种使用情况：

1. 类没有覆盖equals() 方法。则通过 equals() 比较该类的两个对象时， 等价于通过“==”比较这两个对象。
2. 类覆盖了equals()方法（即重写equals方法）。可以自定义比较的内容，若比较的内容相等，则返回true（认为这两个对象相等）

**注意：**

1. String中的equals方法是被重写过的，因为object的equals方法是比较的对象的 内存地址，而String的equals方法比较的是对象的值

2. 当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要 创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建 一个String对象  （可以用String是最终类解释）

### hashCode

hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整 数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义 在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode()函数

#### 为什么要有hashCode

使用hashCode可以大大减少equals的次数，大大提高了执行速度。

以 HashSet如何检查重复 为例子说明

当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对 象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果 没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相 同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对 象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。

#### 重写了equals() 为什么必须要重写hashCode()

因为不重写hashCode方法时，可能会出现equals方法返回为true，而hashCode方法却返回false

因为在有些时候（例如在HashMap和HashSet中）在比较引用类型的时候会先比较hashCode，如果hashCode一致才会执行equals方法。

例如：

```
HashSet<Person> set = new HashSet<>();

Person p1 = new Person("张三", 18);
Person p2 = new Person("张三", 18);
set.add(p1);
set.add(p2);

System.out.println(set.size());

//此时set的大小为2，明显不合理，因为set存放的元素不能重复。
```

那么一般如何重写hashCode()呢

```
@Override
public int hashCode() {
    return Objects.hash(name, age);
}
```

## 值传递

当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？

ans：是值传递。Java 语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的

**值传递与引用传递的区别**

值传递：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷 贝，也就是说传递后就互不相关了。 引用传递：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引 用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说 传递前和传递后都指向同一个引用（也就是同一个内存空间）。
