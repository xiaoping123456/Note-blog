# RabbitMQ基础

## MQ

### 什么是MQ?

MQ(message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是message 而已，还是一种跨进程的通信机制，用于上下游传递消息.

### 为什么使用MQ?

1. **异步处理** - 相比于传统的串行、并行方式，提高了系统吞吐量。
2. **应用解耦** - 系统间通过消息通信，不用关心其他系统的处理。
3. **流量削锋** - 可以通过消息队列长度控制请求量；可以缓解短时间内的高并发请求。
4. 日志处理 - 解决大量日志传输。
5. 消息通讯 - 消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通 讯。比如实现点对点消息队列，或者聊天室等。

主要优点是：**异步，解耦，削峰**

- 流量削峰

  把一秒内要完成的事分散成一段时间去完成，让服务器的性能更多的去处理业务，而不是实现业务。用消息队列做缓冲，这样主业务运行时，只需要把消息存到消息队列中，让其他服务去完成，不用自己去完成工作，因此可以大大的提高主业务服务器的性能。

- 应用解耦

  一个业务会用到多个服务，当某个业务中的某个服务挂掉的时候，系统会出现故障，使用MQ就可以把任务放到消息队列中，让服务去消息队列中消费。

  以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。

  ![image-20220806102202026](https://picgo111.oss-cn-beijing.aliyuncs.com/image-20220806102202026.png)

- 异步处理

  有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可以执行完，以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api， B 执行完之后调用 api 通知 A 服务。这两种方式都不是很优雅，使用消息总线，可以很方便解决这个问题，A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此消息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样 B 服务也不用做这些操作。A 服务还能及时的得到异步处理成功的消息。

  ![image-20220806103018326](https://picgo111.oss-cn-beijing.aliyuncs.com/image-20220806103018326.png)

### MQ的选择

1. ActiveMQ
2. RabbitMQ
3. RocketMq
4. KafKa



## RabbitMQ 概述

### 四大核心概念

- 生产者

  产生数据发送消息的就是生产者

- 交换机

  交换机是RabbitMQ的一个重要组件，一方面它接收来自生产者的消息，另一方面它将消息推送到队列中。

  交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或者是把消息丢弃，这个得有交换机类型决定。

- 队列

  队列是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式

- 消费者

  消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者。

### 工作组成

![image-20220806104241332](https://picgo111.oss-cn-beijing.aliyuncs.com/image-20220806104241332.png)

**名词介绍**

- **Broker**

  接收和分发消息的应用

- **Virtual host**

  出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等

- **Connection**

  publisher(生产者) / consumer(消费者) / broker之间的TCP连接

- **Channel**

  信道是生产消费者与rabbit通信的渠道，生产者publish或者消费者消费一个队列都是需要通过信道来通信的。

  信道是建立在TCP上面的虚拟链接，也就是rabbitMQ在一个TCP上面建立成百上千的信道来达到多个线程处理。TCP消耗资源,TCP链接可以容纳无限的信道，不会有并发上面的性能瓶颈。

  **注意是一个TCP 被多个线程共享，每个线程对应一个信道，信道在rabbit都有唯一的ID，保证了信道的私有性，对应上唯一的线程使用。**

- **Exchange**

  message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到 queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)

- **Queue**

  消息最终被送到这里等待 consumer 取走

- **Binding**

  exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key，Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据

### 五大工作模式

#### 一、简单模式 simple

当生产者发送消息到交换机，交换机根据消息属性发送到队列，消费者监听绑定队列，实现消息的接收和消息逻辑的编写。简单模式下，强调**一个队列只被一个消费者监听消费**

![image-20220806111618145](https://picgo111.oss-cn-beijing.aliyuncs.com/image-20220806111618145.png)

#### 二、工作模式（争抢模式）work

多个消费者，同时绑定监听一个队列，之间形成了争抢消息的结果

![image-20220806111915366](https://picgo111.oss-cn-beijing.aliyuncs.com/image-20220806111915366.png)

#### 三、路由模式 route

将消息携带routing key 和队列绑定routing key ，只有routing key匹配上了，交换机才会把消息发送给队列

![image-20220806112246964](https://picgo111.oss-cn-beijing.aliyuncs.com/image-20220806112246964.png)

#### 四、发布订阅模式 fanout

交换机把数据发送给所有与其绑定的队列（不用管routing key是否匹配）

![image-20220806112357581](https://picgo111.oss-cn-beijing.aliyuncs.com/image-20220806112357581.png)

#### 五、主题模式 topic

非常类似于路由模式的结构,区别在于后端队列绑定交换机使用的路由key.

主体模式下routing key 可以进行模糊匹配

模糊匹配原则：1）#：多级路径，多个字符 2）*：一级路径，多个字符

![image-20220806112604601](https://picgo111.oss-cn-beijing.aliyuncs.com/image-20220806112604601.png)

## RabbitMQ 消息应答

消息应答机制：消费者在接收到消息并处理该消息后，告诉rabbitMQ它已经处理了，rabbitMQ可以把消息删除了。

### 自动应答

消息发送后立即被认为已经传送成功

这种模式需要在**高吞吐量和数据传输安全性方面做权衡**,因为这种模式如果消息在接收到之前，消费者那边出现连接或者 channel 关闭，那么消息就丢失了,当然另一方面这种模式消费者那边可以传递过载的消息，**没有对传递的消息数量进行限制**，当然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压，最终使得内存耗尽，最终这些消费者线程被操作系统杀死，所以**这种模式仅适用在消费者可以高效并以某种速率能够处理这些消息得情况下使用。**

### 消息应答的方法

1. Channel.basicAck()

   用于肯定确认，RabbitMQ已经知道该消息并且成功的处理消息，可以将其丢弃了

   ```java
   channel.basicAck(long deliveryTag, boolean multiple);
   // 第一个参数 deliveryTag是消息的标记
   // 第二个参数 multiple代表是否批量应答
   ```

2. Channel.basicNack()

   用于否定确认

3. Channer.basicReject()

   用于否定确认，basicNack()不同的是少了一个参数

   不处理该消息了，直接拒绝，可以将其丢弃了

**Multiple的解释**

手动应带的好处是可以批量应答并且减少网络拥堵

multiple的true和false代表不同的意思

- true :

   代表批量应答channel上未应答的消息，比如说 channel 上有传送 tag 的消息 5,6,7,8 当前 tag 是 8 那么此时5-8 的这些还未应答的消息都会被确认收到消息应答

- false :

  同上边相比，只会应答 tag=8 的消息 5,6,7 这三个消息依然不会被确认收到消息应答

### 消息自动重新入队

如果消费者由于某些原因失去连接(其通道已关闭，连接已关闭或 TCP 连接丢失)，导致消息未发送 ACK 确认，RabbitMQ 将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息。

